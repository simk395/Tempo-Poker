import { cities as db }  from "./db/cities.js"
import Weather from "./components/Weather.js"
import Dice from "./components/Dice.js"
import Player from "./components/player.js"
import Deck from "./components/Deck.js"
import Food from "./components/Food.js"

// usage of web storage and initiaize state machine
const storage = localStorage;
const state = {}

// create players
function generatePlayers(){
    // checking for player data
    const players = JSON.parse(storage.getItem("players"));
    
    // return the an array of data player that has been generated by the system
    // The system will also display avatars to the page based on user choices and
    // position them to their previous spot if there was a game saved
    return players.map( (player, i) => {
        let div = document.querySelector(`div[data-player="${i}"]`);
        let icon = document.createElement("img");
        icon.className = "player";
        icon.src = `images/playerIcons/${player.color}.png`;
        icon.dataset.icon = i;
        div.append(icon);
        if(player.space > 0){
            advance(player);
        }
        Object.values(player.items.cards).forEach(card => {
            appendCard(player,card);
        })
        return new Player(i, player.name, player.color, parseInt(player.space), player.items)
    });
}

//get weather data into an array
async function generateWeather(){
    // attempt to request for weather data from Dark Sky API
    // If failure to obtain whether then notify the users
    try{
        const size = parseInt(storage.getItem("board"));
        const citySize = db.length;
        const numOfForecasts = Math.floor(size/50);
        const weathers = [];
        
        // Save all information into an array to be stored into the state machine
        // Also save the data into the database to ensure players can continue where they left off
        for(let i = 0; i < numOfForecasts; i++){
            let val = Math.floor(Math.random()*citySize);
            let city = db[val];
            let forecast = new Weather(city.lat, city.lng, city.city, city.country);
            await forecast.getWeather();
            weathers.push(forecast);
        } 
        
        let data = JSON.stringify(weathers);
        storage.setItem("weathers", data);
        return weathers;
    }catch(e){
        alert("Failed to get weather");
    }
    
}

// make weather visible to players
function appendWeather(weather){
    // creation of many elements to display weather for users to see
    const weatherContainer = document.querySelector("#weather");

    const col = document.createElement("div");
    col.className = 'col weather-col';

    const container = document.createElement("div");
    container.className = `d-flex flex-row justify-content-around align-items-center`;

    const title = document.createElement("p");
    title.className = "text-center weather-title";
    title.innerText = `${weather.city}, ${weather.country}`;

    const icon = document.createElement("i");

    // Weather icons will be determined by the data retrieved/current weather forecast
    switch(weather.type){
        case 'clear-day': icon.className = 'fas fa-sun fa-2x'; break;
        case 'clear-night': icon.className = 'fas fa-moon fa-2x'; break;
        case 'partly-cloudy-day': icon.className = 'fas fa-cloud-sun fa-2x'; break;
        case 'partly-cloudy-night': icon.className = 'fas fa-cloud-moon fa-2x'; break;
        case 'rain': icon.className = 'fas fa-cloud-rain fa-2x'; break;
        case 'snow': icon.className = 'fas fa-snowflake fa-2x'; break;
        default: icon.className = 'fas fa-cloud fa-2x'; break;
    }

    const temperature = document.createElement("p");
    temperature.innerHTML = `${weather.temp} &#730`;
    temperature.className = "temp";

    container.append(icon, temperature);
    col.append(title, container);
    weatherContainer.append(col);
}


//signal the beginning of a turn
// player's turn will
async function beginTurn(){
    const {players, turn} = state;
    const player = players[turn];
    const inventory = document.querySelector(`.inventory[data-bag="${player.id}"]`);
    inventory.addEventListener("click", (e) => handleInventory(e, player, inventory));
    appendRoll(player);
}

// Event to fire when interacting with the inventory
function handleInventory(e, player, inventory){
    const { cards } = state;
    // check whether target clicked is a food or card
    const data = Object.keys(e.target.dataset)[0];

    if(data === "card"){

        const code = e.target.dataset.card;
        // check if the card has been clicked before
        const deselect = cards.findIndex(card => card == code);

        if(deselect !== -1) {
            // deselect the card
            state.cards = cards.filter(card => card !== code);
            e.target.classList.toggle("active");
        }
        else if(cards.length >= 5) return;
        else {
            // add card to the selection 
            state.cards.push(code)
            e.target.classList.toggle("active");
        };
    
        if(state.cards.length) appendUse(player, inventory);
        else removeUse();

    }else if(data === "food"){
        // if the target is a food then apply food functionality and remove it from the display
        const item = e.target.dataset.food;
        const food = player.items.foods[item][0];
        let speed = player.useFood(food);
        updateSpeed(speed, player);
        player.deleteFood(item);
        e.target.remove();
    }
   
}

// add Use button for users to exchange cards
function appendUse(player, inventory){
    const btn = document.querySelector("#use");
    if(btn) return;

    const use = document.createElement("input");
    use.type = "image";
    use.src = "../public/images/use.png";
    use.id = "use";
    use.className = "btn";
    use.addEventListener("click", e => handleUse(player));
    inventory.parentElement.append(use);
}

// remove Use button
function removeUse(){
    const btn = document.querySelector("#use");
    if(btn) btn.remove();
}

// Event functionality to be fired when clicking on the use button
// The functionality is to trade in a combination of cards for a food item
async function handleUse(player){
    const { cards } = state;
    // trade in/use cards
    let val = player.useCard(cards);
    // check if card were a valid combination
    if(val){
        // the index value returned will be the indicator to which items will be obtained from the foods array
        // a ranking system for food is established with this implementation
        const foods = ["apple", "banana", "rice", "tea","soda","chocolate","energy%20drink", "coffee"];
        const food = await new Food().getFood(foods[val-1]);
        food.value = val;
        player.addFood(food);
        appendFood(player,food);
        // remove all selected cards when using them
        cards.forEach(card => {
            removeCard(card)
            player.deleteCard(card);
        });
        state.cards = [];
        removeUse();
    }else{
        alert("invalid card combination");
    }
}

// show food in inventory
function appendFood(player, food){
    const inventory = document.querySelector(`.inventory[data-bag="${player.id}"]`);
    const img = document.createElement("img");
    img.className = "food";
    img.src = food.photo.thumb;
    img.dataset.food = food.food_name;
    inventory.append(img);
}

// remove card images that were used
function removeCard(card){
    const img = document.querySelector(`.card[data-card="${card}"]`);
    if(img) img.remove();
}


// add the roll button to respective players turn
function appendRoll(player){
    const inventory = document.querySelector(`.inventory[data-bag="${player.id}"]`);
    const btn = document.createElement("input");
    btn.type = "image";
    btn.src = "../public/images/roll.png";
    btn.innerText = "roll";
    btn.className = "btn";
    btn.id = "roll"
    btn.addEventListener("click", e => handleDice(player));
    inventory.after(btn);
}

//handle rolling the dice
function handleDice(player){
    const {weathers, dice} = state;
    const size = parseInt(storage.getItem("board"));
    const distance = dice.roll(player, weathers, size);
    player.move(size, distance);
    advance(player);
    endTurn(player, distance);
}

// slide the player forward
function advance(player){
    const size = parseInt(storage.getItem("board"));
    const playerIcon = document.querySelector(`.player[data-icon="${player.id}"`);
    const pct = Math.floor((player.space / size)*100);
    if(pct >= 3){
        playerIcon.style.transform = `translateX(calc(${pct}vw - 50px))`;
    }
}

// end the player's turn
async function endTurn(player, distance){
    const {players, deck, turn} = state;
    // try to draw a card from the deck.
    // If the player was unable to obtain a card then let them roll again
    // Players will not move unless they received a card
    try{
        const card = await deck.draw(deck.id);
        updateMove(distance, player);
        player.addCard(card);
        appendCard(player, card);
        removeRoll();
        removeSelect(player);
        state.cards = [];
        removeUse();
        if(player.space >= 150){
            alert(`${player.name} wins!`);
            appendPlayAgain();
            return;
        }
        if(turn + 1 === players.length) state.turn = 0;
        else state.turn++;
        beginTurn()
    }catch(err){
        alert("failed to obtain card. Please roll again");
    }
}

// add play again button to the display
function appendPlayAgain(){
    const div = document.querySelector("#center");
    const btn = document.createElement("input");
    btn.type = "image";
    btn.src = "../public/images/play_again.png";
    btn.className = "btn-sm";
    btn.addEventListener("click", () => {
        storage.clear();
        window.location.href = "./create.html";
    })
    div.append(btn);

}

// remove roll button for player
function removeRoll(){
    const btn = document.querySelector("#roll");
    if(btn) btn.remove();
}

// create copy to remove listener on inventory
function removeSelect(player){
    const inventory = document.querySelector(`.inventory[data-bag="${player.id}"]`);
    const copy = inventory.cloneNode(true);
    inventory.replaceWith(copy);
}

// add activity to textarea
function updateMove(d, player){
    const log = document.querySelector("#log");
    log.innerHTML = log.innerHTML + `\n${player.name} moved ${d} spaces. Now at ${player.space}.`;
    log.scrollTop = log.scrollHeight;
}

function updateSpeed(speed, player){
    const log = document.querySelector("#log");
    log.innerHTML = log.innerHTML + `\n${player.name}'s speed increased by ${speed}. Will now move ${player.speed} faster.`;
    log.scrollTop = log.scrollHeight;
}

// visually add card to respective player's inventory
function appendCard(player, card){
    const inventory = document.querySelector(`.inventory[data-bag="${player.id}"]`);
    const img = document.createElement("img");
    img.dataset.card = card.code;
    img.className = "card";
    img.src = card.image;
    inventory.append(img);
}

// main
async function main(){
    // Redirect user to creation page if game data is missing
    if(!storage.getItem("board") || !storage.getItem("board") || !storage.getItem("players")) window.location.href = "./create.html";
    
    //generate objects to be used for game 
    const players = generatePlayers();
    const deck = await new Deck().getDeck();
    const weathers = await generateWeather();
    weathers.forEach(weather => {
        appendWeather(weather);
    })
    const dice = new Dice();
    // randomize who starts the game
    const turn = Math.floor(Math.random() * players.length);

    // generate data for state machine
    state.players = players;
    state.deck = deck;
    state.weathers = weathers;
    state.dice = dice;
    state.turn = turn;
    state.cards = [];

    // save progress upon leaving the site
    window.onbeforeunload = function (e){
        storage.setItem("players", JSON.stringify(players));
    }

    // start the game
    beginTurn();
}


main();